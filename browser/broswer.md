# 浏览器渲染原理
1、宏观视角下的浏览器
2、进程与线程之间的关系，chrome启动一个页面有几个进程？
3、计算机网络七层模型
4、HTTP请求流程
5、输入url地址到显示页面发生了什么？

## 宏观视角下的浏览器
c/s client -- server (LOL、王者)
b/s browser -- server (web语雀)

## 进程Process和线程Thread
windows: ctrl+alt+delete
---------
进程： 就是在内存中正在运行的应用程序。
1. 在内存中单独占一个内存空间
2. 进程和线程之间是隔离的

线程： 是进程的最小执行单位
1. 一个进程是由多个线程组成
2. 每一个线程之间也是隔离的
----------
一个页面启动的时候启动几个进程?
* 最少4个进程
1. 浏览器主进程(显示页面、用户交互，解析地址是网络进程)
2. 渲染进程
3. 网络进程
4. GPU进程
● 浏览器进程。主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。
● 渲染进程。 核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中，默认情况下，Chrome为每一个Tab标签页创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下的。
● GPU进程。GPU图形处理器（英语：graphics processing unit，缩写：GPU）,负责3D css效果，网页，Chrome ui的绘制。
● 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。
● 插件进程。主要负责插件的运行，因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 计算机网络的七层模型
1. 物理层：使用一定的物理介质（光纤、网线、wifi) 01电信号传输
2. 数据链路层： MAC地址  封装byte
3. 网络层 IP 协议
4. 传输层 UDP（用户数据包协议） TCP（传输控制协议）
5. 会话层 -- 断点续传（没有协议） 计算机网络中没有协议的层都不太重要
6. 表示层 翻译 解决不同系统之间数据传输的问题
7. 应用层 HTTP协议

UDP协议的特点：只管发，不管收-比如：DNS解析（Wireshark抓包看）、微信电话、流媒体等
TCP
1. 重传机制 （三次握手 你：中午一起吃饭吗？她：可以，一起吃饭 没回复... 她： 嗯？一起吃饭？ 你： OK）
2. 排序机制--根据数据包的编号对数据进行排序，重组数据包，保证数据包的完整性和准确性

## 四层
1. 物理层 （数据链路）
2. 网络层
3. 传输层
4. 应用层 会话层 表示

IP/UDP/TCP/HTTP

## 浏览器发送HTTP的请求流程
1. 构造请求行
GET /api/xxx HTTP 1.1
2. 查找缓存  有缓存取缓存 没有就发送网络请求
3. 准备IP地址（网络层）和端口号（传输层）
4. 等待TCP队列  （chrome机制： 一个域名最多建立6个TCP链接）
5. 建立TCP连接
6. 发送HTTP请求

服务器处理HTTP请求
1. 返回请求的内容
2. 断开连接

## 进程的角度的渲染流程
输入url地址到浏览器显示页面的过程到底发生了什么？
1. 浏览器主进程 2. 网络进程 3. 渲染进程
我们首先回顾一下浏览器进程、渲染进程、和网络进程的主要职责。
● 浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
● 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
● 渲染进程的主要职责就是把从网络上下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和用户交互的页面。 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所有运行在渲染进程里的代码是不被信任的。这也是为什么Chrome会让渲染进程运行在安全沙箱中，就是为了保证系统的安全。
回顾了浏览器的进程架构之后，我们再结合上图我们从进程的角度，描述一下
1、浏览器进程接收到用户输入的URL请求，浏览器进程便将URL转发给网络进程
2、网络进程中发起真正的URL请求
3、网络进程接收到响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
4、浏览器进程接收到网络进程的响应头数据之后，发送"提交文档"消息到渲染进程；
5、渲染进程接收到"提交文档"的消息之后，便开始准备接收HTML数据，接收数据的方式是直接和网络进程建立数据管道。
6、等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
7、浏览器进程接收到渲染进程"确认提交"的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。
所谓提交文档，就是浏览器主进程，将网络进程接收到的HTML数

## 浏览器角度的渲染流程(F12 performance 最小的时间刻度去看Main浏览器主进程)
1. 使用html解析器将html页面转换成浏览器能够理解的DOM树 parseHTML
2. 将css解析成浏览器能够识别的CSSOM 语法树
3. 样式计算
4. DOM树+CSS树 --> 布局树 layout tree
5. 根据布局树生产图层树 layer tree (下面的特定情况触发)
6. paint绘制-GPU完成 （一个一个绘制(一个一个div元素等)）
7. 组合图层 composition layer 生产最终的页面

* 有什么会被称为图层（F12 layers查看 类似 ps的图层）？
1. 3d转换
2. postion fixed
3. video标签
4. canvas标签
5. css3动画 animation

浏览器每次可以接收多大的数据？
* 64kb 
* html的img标签src插入一张图可以测试为什么是 64kb
* 仍是F12 Performance -> 下面的event log 的 Activity 里面的 parse HTML 的 同时有很多次的receice Data 再看右边的 encodeed data 的65536 byte / 1024 = 64kb --> 同时有很多次的receice data 然后 finish loading --> 证明结束
## 重排、重绘 （性能优化切入点）看F12performance的main 渲染流水线
浏览器是根据图层来渲染的，如果非要重排重绘，尽量考虑把变化的元素提升为一个图层，如果F12的layouts里面有三个图层那么就会三次paint，比如will-change: transform; transform: translateX(100px)提升为图层;多用CSS3代替top、left等;

* layout重排：重新计算元素的集合（位置信息、宽高等 先layout 后paint 说明重排一定会重绘）
* paint重排：元素在计算机的视觉表现（颜色等 只有重绘）

优化：
1. 直接使用transform会触发重排和重绘
2. 配合postion: relative只会触发 只会触发重绘
3. 元素作为一个单独的图层处理使用transfrom不会触发重绘也不会触发重排,非常节省浏览器性能（will-change: transform）

* opacity代替visibility更好
1. opacity单独使用会重排会重绘
2. opacity配合图层既不会layout也不会Paint，即不会重排也不会重绘

* 不要获取DOM属性放到循环遍历中