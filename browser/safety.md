# 浏览器安全
## 同源策略（same origin policy）

* 协议（http https ftp）+ 子域名 + 主域名 + 端口 有一个不一样叫跨域
* https://www.baidu.com 和 https://a.baidu.com 不同源 跨域

* 不同源 Dom和Cookie和web storage 不可访问
* 不同源 限制XMLhttpRequest ajax的网络请求（可设置CROS跨域资源共享完成跨域）

------------------
不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施。但是这会使得Web项目难以开发和使用，因为我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的就是XSS攻击和CSRF攻击。
------------------

## XSS攻击 Cross Site Script 跨域脚本攻击（CSP应对）
危害：
1. document.cookie窃取信息
2. addEventListen监听用户行为
3. 修改DOM 伪造登录窗口 骗取用户名密码
4. 页面内生成浮窗广告影响 用户体验

* 如何注入恶意脚本
1. 存储型XSS -> 表单输入提交js脚本(服务器对关键字没过滤)再次阅读这份存储的数据时候就会下载到浏览器去做一些窃取的行为，窃取的数据可以通过ajax上传到注入恶意脚本的黑客的服务器中去

2. 反射型XSS -> 恶意脚本属于用户发送请求的一部分，随后服务器又把恶意脚本返回给用户。当恶意脚本在用户页面中被执行时，黑客就可以利用恶意脚本做一些操作。

3. DOM型XSS
基于DOM的XSS攻击是不会牵涉到页面Web服务器的。具体来说，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面，修改页面。这种劫持类型很多，有通过WiFi路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在Web资源传输过程或者在用户使用页面的过程中修改Web页面的数据。

* 应对
1. CSP content-secure-policy 内容安全策略
2. HttpOnly 为true 大多数XSS都为的cookie
3. 服务端正则过滤

## CSRF 跨域请求伪造攻击 Cross-site request forergy
CSRF(Cross-site request forgery)跨站请求伪造；顾名思义，是伪造请求，冒充用户在站内的正常操作；
该攻击可以在受害者毫不知情的情况下，以受害者名义伪造请求，发送给受攻击的站点。从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性，具体来讲，CSRF攻击。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的。但是却完成了攻击者所期望的一个操作，比如以你的名义，发送邮件发送消息，盗用你的账号，添加系统管理员。

1、李四登录了Gmail邮箱，Gmail服务器返回一些登录状态给李四的浏览器。这些信息包括了Cookie,Session等，这样在李四的浏览器，Gmail处理登录状态了。
2、黑客通过各种手段引诱李四去打开他的链接，比如hack.com,然后再在hack.com页面中，黑客编写好了一个邮箱过滤器，并通过Gmail提供的HTTP设置接口设置了新的邮件过滤功能，该过滤器会将李四的邮件都转发到黑客的邮箱中。
一、什么是CSRF攻击
跨站请求伪造，指黑客引用用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF攻击就是黑客利用了用户的登录状态，并通过第三方站点来做一些坏事。
 
用户登录微博账号，这时黑客给你一个美女图片的链接，你点击之后进入黑客的网站，他获取你的登录状态，利用你的账号传播一些乱七八糟的信息。
和XSS不同的是，CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。
你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

二、如何防止CSRF攻击
发起CSRF攻击的三个必要条件
1、目标站点一定要有CSRF漏洞
2、用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态,没有退出登录。
3、用户需要打开第三方站点，可以是黑客网站，也可以是一些论坛。
满足三个条件，黑客就可以进行CSRF攻击了，这里需要注意的是，与XSS不同，CSRF攻击不需要注入脚本，因此黑客无法通过CSRF攻击来获取用户页面数据；其最关键一点是要找到服务器的漏洞，所以说对于CSRF攻击我们主要的防护手段是提升服务器的安全性。

以下有几种途径可以让服务器避免遭受CSRF攻击
1、充分利用好Cookie的sameSite属性
黑客会利用用户的登录状态来发起CSRF攻击,而Cookie正式浏览器和服务器之间为耻登录状态的一个关键数据。因此要阻止CSRF攻击，首先要考虑的就是在Cookie上做文章。
通常CSRF攻击都是从第三方站发起的，要防止。最好能实现第三方站放松请求时进制Cookie的发送。
如果从第三站点发送请求，那么需要浏览器禁止发送某些关键的Cookie数据到服务器；
同一站点发送的请求，正常发送。
使用SameSite属性可以有效降低CSRF攻击的风险。

HTTP响应头中，通过set-cookie字段设置Cookie,可以带上SameSite选项，如下:
set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
SameSite 选项通常有 Strict、Lax 和 None 三个值。
● Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。
● Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
● 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

2、验证请求的来源站点
CSRF攻击大多来自于第三方的站点，因此服务器可以禁止俩字第三方站点的请求。那么如何判断请求是否来自于第三方站点呢?
可以使用HTTP请求的Referer和Origin属性。

Referer是HTTP请求头中的一个字段，记录了该HTTP请求的来源地址。比如我从百度首页跳转到新闻页，那么请求头中的Referer值是百度的URL
但在服务器端验证请求头中Referer并不是太可靠，因此我们还可以使用Origin属性，在一些重要的场合，比如通过XMLHttpRequest，Fetch发起跨站请求或者通过Post方法发送请求时，都会带上Origin属性
Origin属性只包含了域名信息，并没有包含具体的URL路径，这是Origin和Referer的一个主要区别。
因此服务器的策略是优先判断Origin,如果请求头中没有包含Origin属性，再根据实际情况判断是否使用Referer值。

3、CSRF Token
除了使用以上两种方式来防止CSRF攻击之外，还可以采用CSRF Token来验证，这个流程比较好理解。大致分为两步

第一，在浏览器向服务器发送请求时，服务器生成一个CSRF Token。CSRF Token其实就是服务器生成的字符串，然后将字符串植入到返回的页面中

```
<!DOCTYPE html>
<html>
<body>
    <form action="https://time.geekbang.org/sendcoin" method="POST">
      <input type="hidden" name="csrf-token" value="nc98P987bcpncYhoadjoiydc9ajDlcn">
      <input type="text" name="user">
      <input type="text" name="number">
      <input type="submit">
    </form>
</body>
</html>

第二步，在浏览器如果要发起转账的请求，那么需要带上页面中的CSRF Token，然后服务器会验证该Token是否合法。如果是从第三方站发出的请求，那么将无法获取到CSRF Token,所以即使发出了请求，服务器也会因为CSRF Token不正确而拒绝请求。
